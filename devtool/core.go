package devtool

import (
	"errors"
	"fmt"
	"github.com/VictorLowther/crowbar-devtool/commands"
	"github.com/VictorLowther/go-git/git"
	"github.com/gonuts/commander"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

// Placeholder for a barclamp.
// Barclamps are leaf nodes from the point of view of the
// release branching stricture.
type Barclamp struct {
	// All barclamps have to have a name.
	Name string
	// This is the branch in git that the barclamp should
	// be checked out to for a build.
	Branch string
	// The git repo that holds the actual code for the barclamp.
	Repo *git.Repo
}

type BarclampMap map[string]*Barclamp

// A Build is a bundle of barclamps in a release that
// constitute an installable version of Crowbar
// with an addtional deliverable.
type Build interface {
	// The simple name of the build.  This will be something
	// like "master" or "openstack-os-build"
	Name() string
	// The full name of this build.  It is programatically
	// generated by combining the name of the release with the
	// name of the build.
	FullName() string
	// The Release this build is a member of.
	Release() Release
	// A map of the barclamps that are required for this build.
	// This does not include barclamps from this build's parent!
	Barclamps() BarclampMap
	// The parent of this build.  Every release must contain a master
	// build (which holds the core Crowbar barclamps, and has no parent),
	// and all other builds in a release are children of another build.
	Parent() Build
}

type BuildMap map[string]Build

// A Release is a stream of development for Crowbar.
// At any given time we may have multiple Releases.
// A Release consists of a collection of related builds.
type Release interface {
	// Each release must have a name.
	Name() string
	// The builds that are members of this release.
	Builds() BuildMap
	// The parent of this release.
	// We may return nil if there is no parent.
	Parent() Release
}

type ReleaseMap map[string]Release

// A Metadata allows the rest of Crowbar to know what releases and builds
// are available, and (a little later) modify it.  The reason this
// and the above are interfaces is to allow for having multiple ways to
// store the release metadata.
type Metadata interface {
	// All the releases that this metadata source knows about.
	Releases() ReleaseMap
	// All the builds that this metadata source knows about.
	AllBuilds() BuildMap
	// Test to see if Crowbar is using this metadata.
	Probe(*Crowbar) error
}

type Remote struct {
	Priority int
	Urlbase  string
}

type Crowbar struct {
	Repo      *git.Repo
	Barclamps map[string]*git.Repo
	Remotes   map[string]*Remote
	Meta      Metadata
}

var MemoCrowbar *Crowbar

func dieIfError(e error) {
	if e != nil {
		log.Panic(e)
	}
}

func findCrowbar(path string) (res *Crowbar, err error) {
	if MemoCrowbar != nil {
		return MemoCrowbar, nil
	}
	if path == "" {
		path, err = os.Getwd()
		dieIfError(err)
	}
	path, err = filepath.Abs(path)
	dieIfError(err)
	repo, err := git.Open(path)
	if err != nil {
		return nil, errors.New("Cannot find Crowbar")
	}
	path = repo.Path()
	parent := filepath.Dir(path)
	// If this is a raw repo, recurse and keep looking.
	if repo.IsRaw() {
		res, err = findCrowbar(parent)
		return
	}
	// See if we have something that looks like a crowbar repo here.
	stat, err := os.Stat(filepath.Join(path, "barclamps"))
	if err != nil || !stat.IsDir() {
		res, err = findCrowbar(parent)
		return
	}
	// We do.  Populate the crowbar struct.
	res = &Crowbar{
		Repo:      repo,
		Barclamps: make(map[string]*git.Repo),
		Remotes:   make(map[string]*Remote),
	}
	dirs, err := ioutil.ReadDir(filepath.Join(path, "barclamps"))
	dieIfError(err)
	// populate our list of barclamps
	for _, bc := range dirs {
		if !bc.IsDir() {
			continue
		}
		stat, err = os.Lstat(filepath.Join(path, "barclamps", bc.Name(), ".git"))
		if err != nil {
			log.Println(err)
			continue
		}
		mode := stat.Mode()
		if (mode & (os.ModeDir | os.ModeSymlink)) == 0 {
			continue
		}
		repo, err = git.Open(filepath.Join(path, "barclamps", bc.Name()))
		if err != nil {
			log.Println(err)
			continue
		}
		res.Barclamps[bc.Name()] = repo
	}
	// populate remotes next
	cfg, err := res.Repo.Config()
	dieIfError(err)
	remotes := cfg.Find("crowbar.remote.")
	var rem *Remote
	for k, v := range remotes {
		parts := strings.Split(k, ".")
		if res.Remotes[parts[2]] == nil {
			rem = new(Remote)
			res.Remotes[parts[2]] = rem
		} else {
			rem = res.Remotes[parts[2]]
		}
		switch parts[3] {
		case "priority":
			rem.Priority, _ = strconv.Atoi(v)
		case "urlbase":
			rem.Urlbase = v
		}
	}
	res.Meta = new(FlatMetadata)
	err = res.Meta.Probe(res)
	if err != nil {
		return nil, err
	}
	MemoCrowbar = res
	return res, nil
}

func mustFindCrowbar(path string) *Crowbar {
	res, err := findCrowbar(path)
	dieIfError(err)
	return res
}

func (c *Crowbar) Releases() ReleaseMap {
	return c.Meta.Releases()
}

func (c *Crowbar) Builds() BuildMap {
	return c.Meta.AllBuilds()
}

func (c *Crowbar) Release(release string) Release {
	rels := c.Releases()
	res, ok := rels[release]
	if !ok {
		log.Fatalf("%s is not a release!\n", release)
	}
	return res
}

func ShowCrowbar(cmd *commander.Command, args []string) {
	r := mustFindCrowbar("")
	fmt.Printf("Crowbar is located at: %s\n", r.Repo.Path())
}

func (c *Crowbar) fetch(remotes []string) (ok bool) {
	type tok struct {
		name    string
		ok      bool
		results git.FetchMap
	}
	ok = true
	fetches := len(c.Barclamps) + 1
	results := make([]tok, 0, fetches)
	ch := make(chan tok)
	fetcher := func(name string, repo *git.Repo) {
		ok, items := repo.Fetch(remotes)
		ch <- tok{
			name:    name,
			ok:      ok,
			results: items,
		}
	}
	go fetcher("Crowbar", c.Repo)
	for k, v := range c.Barclamps {
		go fetcher(k, v)
	}
	for {
		result := <-ch
		ok = ok && result.ok
		results = append(results, result)
		if result.ok {
			fmt.Printf("Fetched all changes for %s\n", result.name)
		} else {
			fmt.Printf("Failed to fetch all changes for %s:\n", result.name)
			for k, v := range result.results {
				if !v {
					fmt.Printf("\tRemote %s failed\n", k)
				}
			}
		}
		if len(results) == fetches {
			break
		}
	}
	close(ch)
	return ok
}

func (c *Crowbar) currentRelease() Release {
	cfg, err := c.Repo.Config()
	dieIfError(err)
	res, found := cfg.Get("crowbar.release")
	if found {
		return c.Release(res)
	}
	return nil
}

func (c *Crowbar) currentBuild() Build {
	cfg, err := c.Repo.Config()
	dieIfError(err)
	res, found := cfg.Get("crowbar.build")
	if !found {
		return nil
	}
	builds := c.Builds()
	build, found := builds[res]
	if !found {
		log.Fatalf("Current build %s does not exist!", res)
	}
	return build
}

func (c *Crowbar) barclampsInBuild(build Build) BarclampMap {
	if build == nil {
		log.Panicf("Cannot get barclamps of a nil Build!")
	}
	var res BarclampMap
	if build.Parent() != nil {
		res = c.barclampsInBuild(build.Parent())
	} else {
		res = make(BarclampMap)
	}
	for k, v := range build.Barclamps() {
		res[k] = v
	}
	return res
}

func Fetch(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	if c.fetch(nil) {
		fmt.Printf("All updates fetched.\n")
		os.Exit(0)
	}
	os.Exit(1)
}

func ShowRelease(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	fmt.Println(c.currentRelease().Name())
}

func ShowBuild(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	fmt.Println(c.currentBuild().FullName())
}

func Releases(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	for release, _ := range c.Releases() {
		res = append(res, release)
	}
	sort.Strings(res)
	for _, release := range res {
		fmt.Println(release)
	}
}

func Builds(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	if len(args) == 0 {
		for build, _ := range c.currentRelease().Builds() {
			res = append(res, c.currentRelease().Name()+"/"+build)
		}
	} else {
		for _, release := range args {
			for build, _ := range c.Release(release).Builds() {
				res = append(res, release+"/"+build)
			}
		}
	}
	sort.Strings(res)
	for _, build := range res {
		fmt.Println(build)
	}
}

func BarclampsInBuild(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	var build Build
	var found bool
	if len(args) == 0 {
		build = c.currentBuild()
	} else if len(args) == 1 {
		builds := c.Builds()
		build, found = builds[args[0]]
		if !found {
			log.Fatalln("No such build %s", args[0])
		}
	}
	for name, _ := range c.barclampsInBuild(build) {
		res = append(res, name)
	}
	sort.Strings(res)
	for _, name := range res {
		fmt.Println(name)
	}
}

func init() {
	commands.AddCommand(
		&commander.Command{
			Run:       Releases,
			UsageLine: "releases",
			Short:     "Shows the releases available to work on.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       BarclampsInBuild,
			UsageLine: "barclamps-in-build [build]",
			Short:     "Shows the releases available to work on.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       Builds,
			UsageLine: "builds",
			Short:     "Shows the builds in a release or releases.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowRelease,
			UsageLine: "release",
			Short:     "Shows the current release",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowBuild,
			UsageLine: "branch",
			Short:     "Shows the current branch",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowCrowbar,
			UsageLine: "show",
			Short:     "Shows the location of the top level Crowbar repo",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       Fetch,
			UsageLine: "fetch",
			Short:     "Fetches updates from all remotes",
		})
	return
}

func Run() {
	commands.Run()
	return
}
