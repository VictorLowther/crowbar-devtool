package devtool

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/VictorLowther/go-git/git"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Placeholder for a barclamp.
// Barclamps are leaf nodes from the point of view of the
// release branching stricture.
type Barclamp struct {
	// All barclamps have to have a name.
	Name string
	// This is the branch in git that the barclamp should
	// be checked out to for a build.
	Branch string
	// The git repo that holds the actual code for the barclamp.
	Repo *git.Repo
}

type BarclampMap map[string]*Barclamp

type RepoMap map[string]*git.Repo

// A Build is a bundle of barclamps in a release that
// constitute an installable version of Crowbar
// with an addtional deliverable.
type Build interface {
	// The simple name of the build.  This will be something
	// like "master" or "openstack-os-build"
	Name() string
	// The full name of this build.  It is programatically
	// generated by combining the name of the release with the
	// name of the build.
	FullName() string
	// The Release this build is a member of.
	Release() Release
	// A map of the barclamps that are required for this build.
	// This does not include barclamps from this build's parent!
	Barclamps() BarclampMap
	// The parent of this build.  Every release must contain a master
	// build (which holds the core Crowbar barclamps, and has no parent),
	// and all other builds in a release are children of another build.
	Parent() Build
	// Perform whatver metadata-specific tasks are needed to
	// finaize a switch operation.
	FinalizeSwitch()
}

type BuildMap map[string]Build

// A Release is a stream of development for Crowbar.
// At any given time we may have multiple Releases.
// A Release consists of a collection of related builds.
type Release interface {
	// Each release must have a name.
	Name() string
	// The builds that are members of this release.
	Builds() BuildMap
	// The parent of this release.
	// We may return nil if there is no parent.
	Parent() Release
}

type ReleaseMap map[string]Release

// A Metadata allows the rest of Crowbar to know what releases and builds
// are available, and (a little later) modify it.  The reason this
// and the above are interfaces is to allow for having multiple ways to
// store the release metadata.
type Metadata interface {
	// All the releases that this metadata source knows about.
	Releases() ReleaseMap
	// All the builds that this metadata source knows about.
	AllBuilds() BuildMap
	// Test to see if Crowbar is using this metadata.
	Probe(*Crowbar) error
}

// Track the priority of a Crowbar remote.
type Remote struct {
	Priority      int
	Urlbase, Name string
}

// The master struct for managing Crowbar instances.
type Crowbar struct {
	Repo      *git.Repo
	Barclamps RepoMap
	Remotes   map[string]*Remote
	Meta      Metadata
}

// The current instance of Crowbar we operate on.
var MemoCrowbar *Crowbar

// If e is of type error, log it as a fatal error and die.
// Otherwise, don't do anything.
func dieIfError(e error) {
	if e != nil {
		log.Fatal(e)
	}
}

// Find Crowbar from the current path.
func findCrowbar(path string) (res *Crowbar, err error) {
	if MemoCrowbar != nil {
		return MemoCrowbar, nil
	}
	if path == "" {
		path, err = os.Getwd()
		dieIfError(err)
	}
	path, err = filepath.Abs(path)
	dieIfError(err)
	repo, err := git.Open(path)
	if err != nil {
		return nil, errors.New("Cannot find Crowbar")
	}
	path = repo.Path()
	parent := filepath.Dir(path)
	// If this is a raw repo, recurse and keep looking.
	if repo.IsRaw() {
		res, err = findCrowbar(parent)
		return
	}
	// See if we have something that looks like a crowbar repo here.
	stat, err := os.Stat(filepath.Join(path, "barclamps"))
	if err != nil || !stat.IsDir() {
		res, err = findCrowbar(parent)
		return
	}
	// We do.  Populate the crowbar struct.
	res = &Crowbar{
		Repo:      repo,
		Barclamps: make(map[string]*git.Repo),
		Remotes:   make(map[string]*Remote),
	}
	dirs, err := ioutil.ReadDir(filepath.Join(path, "barclamps"))
	dieIfError(err)
	// populate our list of barclamps
	for _, bc := range dirs {
		if !bc.IsDir() {
			continue
		}
		stat, err = os.Lstat(filepath.Join(path, "barclamps", bc.Name(), ".git"))
		if err != nil {
			log.Println(err)
			continue
		}
		mode := stat.Mode()
		if (mode & (os.ModeDir | os.ModeSymlink)) == 0 {
			continue
		}
		repo, err = git.Open(filepath.Join(path, "barclamps", bc.Name()))
		if err != nil {
			log.Println(err)
			continue
		}
		res.Barclamps[bc.Name()] = repo
	}
	// populate remotes next

	remotes := res.Repo.Find("crowbar.remote.")
	var rem *Remote
	for k, v := range remotes {
		parts := strings.Split(k, ".")
		if res.Remotes[parts[2]] == nil {
			rem = new(Remote)
			rem.Name = parts[2]
			rem.Priority = 50 // default.
			res.Remotes[parts[2]] = rem
		} else {
			rem = res.Remotes[parts[2]]
		}
		switch parts[3] {
		case "priority":
			p, e := strconv.Atoi(v)
			if e == nil {
				rem.Priority = p
			}
		case "urlbase":
			rem.Urlbase = v
		}
	}
	res.Meta = new(FlatMetadata)
	err = res.Meta.Probe(res)
	if err != nil {
		return nil, err
	}
	MemoCrowbar = res
	return res, nil
}

// This is the same as findCrowbar, except we die if we cannot find Crowbar.
func MustFindCrowbar(path string) *Crowbar {
	res, err := findCrowbar(path)
	dieIfError(err)
	return res
}

// Get all the releases we know about.
func (c *Crowbar) Releases() ReleaseMap {
	return c.Meta.Releases()
}

// Get all of the builds we know how to build.
func (c *Crowbar) Builds() BuildMap {
	return c.Meta.AllBuilds()
}

// Get a specific release.
func (c *Crowbar) Release(release string) Release {
	rels := c.Releases()
	res, ok := rels[release]
	if !ok {
		log.Fatalf("%s is not a release!\n", release)
	}
	return res
}

// Given the name of a release, return what its git branch should be.
func (c *Crowbar) ReleaseBranch(release string) string {
	parts := strings.Split(release, "/")
	if len(parts) == 1 {
		return "release/" + release + "/master"
	} else if len(parts) == 2 && parts[0] == "feature" {
		return "feature/" + parts[1] + "/master"
	} else {
		log.Fatalf("%s is not a valid release name!\n", release)
	}
	return ""
}

// Get all the release branches we care about, sorted by barclamp.
func (c *Crowbar) AllBarclampBranches() (res map[string][]string) {
	res = make(map[string][]string)
	for _, build := range c.Builds() {
		for _, bc := range build.Barclamps() {
			if res[bc.Name] == nil {
				res[bc.Name] = make([]string, 0, 4)
			}
			res[bc.Name] = append(res[bc.Name], bc.Branch)
		}
	}
	return
}

// Get all the barclamp repos, return them in a map whose keys are in the
// of "barclamp-" + the barclamp name.
func (c *Crowbar) AllBarclampRepos() (res RepoMap) {
	res = make(RepoMap)
	for name, bc := range c.Barclamps {
		res["barclamp-"+name] = bc
	}
	return res
}

func (c *Crowbar) AllOtherRepos() (res RepoMap) {
	res = make(RepoMap)
	res["crowbar"] = c.Repo
	return res
}

// Get all of the repositories that make up Crowbar.
func (c *Crowbar) AllRepos() (res RepoMap) {
	res = c.AllBarclampRepos()
	for k, v := range c.AllOtherRepos() {
		res[k] = v
	}
	return res
}

// The result type that all mappers in the repoMapReduce framework expect.
type ResultToken struct {
	// name should be unique among all the mapreduce operations.
	// It will usually be the name of a barclamp or other repository.
	Name string
	// true if the map operations results are valid, false otherwise.
	// We split this out because I expect that most operations will
	// care about rolling this up.
	OK bool
	// A function that will be called to commit this result in the
	// case that all the results are OK.
	commit func(chan<- bool)
	// A function that will be called to roll back any changes this result make.
	// It will be called if any of the mapped results were not OK.
	rollback func(chan<- bool)
	// The detailed result of an individual map function.
	// The framework will treat this as an opaque token.
	Results interface{}
}

func noopCommit(c chan<- bool) { c <- true }

// Make a default ResultToken.
// It pre-populates commit and rollback with functions that do nothing.
func makeResultToken() (res *ResultToken) {
	res = &ResultToken{
		commit:   noopCommit,
		rollback: noopCommit,
	}
	return
}

// Make commit and rollback functions for things that mess with
// the git config file.  This works by saving the contents of the
// git config file, and then discarding the saved changes or writing them out.
func configCheckpointer(r *git.Repo) (commit, rollback func(chan<- bool)) {
	configPath := filepath.Join(r.GitDir, "config")
	stat, err := os.Stat(configPath)
	if err != nil {
		log.Printf("Error stat'ing %s:\n", configPath)
		panic(err)
	}
	if !stat.Mode().IsRegular() {
		log.Panicf("Git config file %s is not a file!\n", configPath)
	}
	configContents, err := ioutil.ReadFile(configPath)
	if err != nil {
		log.Printf("Error opening %s\n", configPath)
		panic(err)
	}
	// By now we have saved the current config file contents.
	// No action for commit, we want to leave the new config alone.
	commit = noopCommit
	// On rollback, restore the old config.
	rollback = func(c chan<- bool) {
		err := ioutil.WriteFile(configPath, configContents, os.FileMode(777))
		if err != nil {
			log.Printf("Failed to restore old config file %s\n", configPath)
			c <- false
		} else {
			c <- true
		}
		r.ReloadConfig()
	}
	return commit, rollback
}

// Make commit and rollback functions for a specific repo where we will
// be messing with the branches.
func branchCheckpointer(r *git.Repo) (commit, rollback func(chan<- bool)) {
	// We only care about branch refernces, and we only want to save
	// the SHA references to the branches.
	refs := make(map[string]string)
	for _, ref := range r.Branches() {
		refs[ref.Name()] = ref.SHA
	}
	// There is no commit action.
	commit = noopCommit
	// On rollback, force all the branches back to where we were.
	rollback = func(c chan<- bool) {
		res := true
		for name, sha := range refs {
			cmd, _, _ := r.Git("branch", "-f", name, sha)
			res = res && (cmd.Run() == nil)
		}
		c <- res

	}
	return
}

// A slice of pointers to result tokens.
type ResultTokens []*ResultToken

// A channel for passing result tokens around.
type resultChan chan *ResultToken

// The function signature that a mapper function must have.
// string should be a unique name that should be derived from the name of a
//   repository in some way.
// *git.Repo is a pointer to a git repository structure.
// resultChan is the channel that the mapper should put its ResultToken on.
// repoMapper must populate the commit and rollback functions in the ResultToken,
// although they can be functions that do nothing.
type repoMapper func(string, *git.Repo, resultChan)

// The function signature that a reducer must have. It should loop over
// the values it gets from resultChan, evaluate overall success or failure,
// and return the overall success or failure along with an array of all the results.
type repoReducer func(resultChan) (bool, ResultTokens)

// Make a basic reducer that can be used if more complicated processing
// during a reduce is not needed.
func makeBasicReducer(items int) repoReducer {
	return func(vals resultChan) (ok bool, res ResultTokens) {
		res = make(ResultTokens, items, items)
		ok = true
		for i, _ := range res {
			item := <-vals
			ok = ok && item.OK
			res[i] = item
		}
		return
	}
}

// Perform operations in parallel across the repositories and collect the results.
// If all the results are OK, then the commit function of each ResultToken is called,
// otherwise the rollback function of each ResultToken is called.
func repoMapReduce(repos RepoMap, mapper repoMapper, reducer repoReducer) (ok bool, res ResultTokens) {
	results := make(resultChan)
	defer close(results)
	for name, repo := range repos {
		go mapper(name, repo, results)
	}
	ok, res = reducer(results)
	crChan := make(chan bool)
	defer close(crChan)
	crOK := true
	for _, t := range res {
		if ok {
			go t.commit(crChan)
		} else {
			go t.rollback(crChan)
		}
	}
	for _, _ = range res {
		crOK = (<-crChan) && crOK
	}
	if !crOK {
		var cr string
		if ok {
			cr = "commit"
		} else {
			cr = "rollback"
		}
		log.Printf("Please email this traceback to crowbar@lists.us.dell.com\n")
		log.Panicf("Unable to %s all repoMapReduce operations!\n", cr)
	}
	return ok, res
}

// Perform a git fetch across all the repositories.
func (c *Crowbar) Fetch(remotes []string) (ok bool, results ResultTokens) {
	repos := c.AllRepos()
	// mapper and reducer are the functions we will
	// hand over to repoMapReduce.
	// mapper is pretty simple, and doesn't really demonstrate
	// anything useful.
	mapper := func(name string, repo *git.Repo, res resultChan) {
		tok := makeResultToken()
		ok, items := repo.Fetch(remotes)
		// Since you cannot unwind a fetch, use the default commit/rollback functions.
		tok.Name, tok.OK, tok.Results = name, ok, items
		res <- tok
	}
	// reducer iterates over all the results as they arrive,
	// printing status messages along the way and keeping
	// a running idea about which fetches worked.
	// It also serves to show off variable capture.
	reducer := func(vals resultChan) (bool, ResultTokens) {
		ok := true
		res := make(ResultTokens, len(repos), len(repos))
		for i, _ := range res {
			item := <-vals
			res[i] = item
			if item.OK {
				log.Printf("Fetched all updates for %s\n", item.Name)
			} else {
				log.Printf("Failed to fetch all changes for %s:\n", item.Name)
				fetch_results, cast_ok := item.Results.(git.FetchMap)
				if !cast_ok {
					log.Panicf("Could not cast fetch results for %s into git.FetchMap\n", item.Name)
				}
				for k, v := range fetch_results {
					if !v {
						log.Printf("\tRemote %s failed\n", k)
					}
				}
			}
			ok = ok && res[i].OK
		}
		return ok, res
	}
	// Now that all the setup is done, do it!
	ok, results = repoMapReduce(repos, mapper, reducer)
	// We do not care about the results of updating tracking branches here.
	c.UpdateTrackingBranches()
	return
}

// See of all our git repositories are clean.
// Clean means there are no uncommitted changes and no untracked files.
func (c *Crowbar) IsClean() (ok bool, results ResultTokens) {
	repos := c.AllRepos()
	mapper := func(name string, repo *git.Repo, res resultChan) {
		ok, items := repo.IsClean()
		tok := makeResultToken()
		// There is nothing to unwind or rollback when testing to see
		// if things are clean.
		tok.Name, tok.OK, tok.Results = name, ok, items
		res <- tok
	}
	ok, results = repoMapReduce(repos, mapper, makeBasicReducer(len(repos)))
	return
}

// Get the current release that this repo set is working in.
func (c *Crowbar) CurrentRelease() Release {
	res, found := c.Repo.Get("crowbar.release")
	if found {
		return c.Release(res)
	}
	return nil
}

// Get the current build that the repo set is working on.
func (c *Crowbar) CurrentBuild() Build {
	res, found := c.Repo.Get("crowbar.build")
	if !found {
		return nil
	}
	builds := c.Builds()
	build, found := builds[res]
	if !found {
		log.Fatalf("Current build %s does not exist!", res)
	}
	return build
}

func (c *Crowbar) setBuild(build Build) {
	c.Repo.Set("crowbar.build", build.FullName())
	c.Repo.Set("crowbar.release", build.Release().Name())
}

// Rebase local changes on top of changes from upstream fetched by a Fetch.
func (c *Crowbar) Rebase() (ok bool, res ResultTokens) {
	repos := c.AllRepos()
	log.Println("Rebasing local branches on remote tracking branches")
	mapper := func(name string, repo *git.Repo, res resultChan) {
		tok := makeResultToken()
		tok.commit, tok.rollback = branchCheckpointer(repo)
		tok.Name, tok.OK, tok.Results = name, true, nil
		for _, branch := range repo.Branches() {
			upstream, err := branch.TrackedRef()
			if err != nil {
				// We don't track anything, don't bother rebasing.
				continue
			}
			if err = branch.RebaseOnto(upstream); err != nil {
				tok.OK = false
				log.Print(err)
				tok.Results = err
				break
			}
		}
		res <- tok
	}
	ok, res = repoMapReduce(repos, mapper, makeBasicReducer(len(repos)))
	return
}

// Get a list of barclamps in a specific Build.
func (c *Crowbar) BarclampsInBuild(build Build) BarclampMap {
	if build == nil {
		log.Panicf("Cannot get barclamps of a nil Build!")
	}
	var res BarclampMap
	if build.Parent() != nil {
		res = c.BarclampsInBuild(build.Parent())
	} else {
		res = make(BarclampMap)
	}
	for k, v := range build.Barclamps() {
		res[k] = v
	}
	return res
}

// Switch a repository to the empty branch, which will be created
// if it does not exist.
func switchToEmptyBranch(r *git.Repo) error {
	contents := bytes.NewBufferString("This branch intentionally left blank\n")
	readme := filepath.Join(r.WorkDir, "README.empty-branch")
	if ref, err := r.Ref("empty-branch"); err == nil {
		return ref.Checkout()
	}
	cmd, _, _ := r.Git("checkout", "--orphan", "empty-branch")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not create empty-branch")
	}
	cmd, _, _ = r.Git("rm", "-r", "--cached", ".")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not remove index from empty-branch")
	}
	cmd, _, _ = r.Git("clean", "-f", "-x", "-d")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not clean working tree for empty-branch")
	}
	if ioutil.WriteFile(readme, contents.Bytes(), os.FileMode(0644)) != nil {
		return fmt.Errorf("Could not create README.empty-branch")
	}
	cmd, _, _ = r.Git("add", "README.empty-branch")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not add README.empty-branch to empty-branch")
	}
	cmd, _, _ = r.Git("commit", "-m", "Created empty branch.")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not create initial commit to empty-branch")
	}
	return nil
}

// Switch the barclamps to the proper branches for a specific build.
// Any barclamps not involved in the build will be set to the empty branch.
func (c *Crowbar) Switch(build Build) (ok bool, res ResultTokens) {
	newBarclamps := c.BarclampsInBuild(build)
	// Build a map of barclamp name -> target branches
	barclampTargets := make(map[string]string)
	for name, _ := range c.Barclamps {
		if _, found := newBarclamps[name]; found {
			barclampTargets[name] = newBarclamps[name].Branch
		} else {
			barclampTargets[name] = "empty-branch"
		}
	}
	mapper := func(name string, repo *git.Repo, res resultChan) {
		targetBranch := barclampTargets[name]
		tok := makeResultToken()
		tok.Name, tok.OK, tok.Results = name, true, nil
		current, err := repo.CurrentRef()
		if err != nil {
			tok.OK = false
			tok.Results = err
		} else if current.Name() != targetBranch {
			tok.Results = fmt.Errorf("Switched %s to %s", current.Name(), targetBranch)
			if targetBranch == "empty-branch" {
				if err = switchToEmptyBranch(repo); err != nil {
					tok.OK = false
					tok.Results = err
				}
			} else if err = repo.Checkout(targetBranch); err != nil {
				tok.OK = false
				tok.Results = err
			}
		}
		res <- tok
	}
	ok, res = repoMapReduce(c.Barclamps, mapper, makeBasicReducer(len(barclampTargets)))
	if ok {
		c.setBuild(build)
		build.FinalizeSwitch()
	}
	return
}
