package devtool

import (
	"bytes"
	"errors"
	"fmt"
	"github.com/VictorLowther/go-git/git"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

// Barclamp is the type that is at the leaf node of the release tracking
// tree.  All metadata types should share the same barclamp struct, so
// we do not hide it behind an interface like we do with the Build, Release,
// and Metadata types.
type Barclamp struct {
	// All barclamps have to have a name.
	Name string
	// This is the branch in git that shoul be checked out for a build.
	Branch string
	// The git repo that holds the actual code for the barclamp.
	Repo *git.Repo
}

// BarclampMap maps barclamp names to pointers to barclamps.
type BarclampMap map[string]*Barclamp

// RepoMap maps repository named to pointers to git repositories.
type RepoMap map[string]*git.Repo

// A Build is a bundle of barclamps in a release that
// constitute an installable version of Crowbar
// with an addtional deliverable.
type Build interface {
	// The simple name of the build.  This will be something
	// like "master" or "openstack-os-build"
	Name() string
	// The full name of this build.  It is programatically
	// generated by combining the name of the release with the
	// name of the build.
	FullName() string
	// The Release this build is a member of.
	Release() Release
	// A map of the barclamps that are required for this build.
	// This does not include barclamps from this build's parent!
	Barclamps() BarclampMap
	// The parent of this build.  Every release must contain a master
	// build (which holds the core Crowbar barclamps, and has no parent),
	// and all other builds in a release are children of another build.
	Parent() Build
	// Perform whatver metadata-specific tasks are needed to
	// finaize a switch operation.
	FinalizeSwitch()
	// Remove a build.  The build must not be named "master", and the
	// build must not have any children.
	Zap() error
}

// BuildMap maps build names to types that satisfy the Build interface.
type BuildMap map[string]Build

// Release is a stream of development for Crowbar.
// At any given time we may have multiple Releases.
// A Release consists of a collection of related builds.
type Release interface {
	// Each release must have a name.
	Name() string
	// The builds that are members of this release.
	Builds() BuildMap
	// The parent of this release.
	// We may return nil if there is no parent.
	Parent() Release
	// Remove metadata for a release.  The branches in the
	// barclamps should be removed before Zapping the release.
	Zap() error
	// All the barclamps in a release
	Barclamps() BarclampMap
	// Metadata operations for finalizing a split of a release
	FinalizeSplit(string, string) (Release, error)
}

// ReleaseMap maps release names to releases.
type ReleaseMap map[string]Release

// Metadata allows the rest of Crowbar to know what releases and builds
// are available, and (a little later) modify it.  The reason this
// and the above are interfaces is to allow for having multiple ways to
// store the release metadata.
type Metadata interface {
	// All the releases that this metadata source knows about.
	Releases() ReleaseMap
	// All the builds that this metadata source knows about.
	Probe() error
}

// Remote tracks the common parts of git remotes across the various
// Crowbar repositories, and provides a mechanism for sorting them.
type Remote struct {
	Priority      int
	Urlbase, Name string
}

var (
	// Repo points at the top-level Crowbar git repository.
	Repo *git.Repo
	// Barclamps tracks all the barclamps that this crowbar checkout
	// knows about.
	Barclamps RepoMap
	// Remotes tracks all the remotes that are configured
	// in the git metadata for this Crowbar checkout.
	Remotes map[string]*Remote
	// Meta holds a reference to the metadata for this Crowbar checkout.
	// This may turn into a slice in the future.
	Meta Metadata
)

// If e is of type error, log it as a fatal error and die.
// Otherwise, don't do anything.
func dieIfError(e error) {
	if e != nil {
		log.Fatal(e)
	}
}

// Find Crowbar from the current path.
func findCrowbar(path string) (err error) {
	if path == "" {
		path, err = os.Getwd()
		dieIfError(err)
	}
	path, err = filepath.Abs(path)
	dieIfError(err)
	repo, err := git.Open(path)
	if err != nil {
		return errors.New("Cannot find Crowbar")
	}
	path = repo.Path()
	parent := filepath.Dir(path)
	// If this is a raw repo, recurse and keep looking.
	if repo.IsRaw() {
		return findCrowbar(parent)
	}
	// See if we have something that looks like a crowbar repo here.
	stat, err := os.Stat(filepath.Join(path, "barclamps"))
	if err != nil || !stat.IsDir() {
		return findCrowbar(parent)
	}
	// We do.  Start populating our stuff.
	Repo = repo
	Barclamps = make(map[string]*git.Repo)
	Remotes = make(map[string]*Remote)
	dirs, err := ioutil.ReadDir(filepath.Join(path, "barclamps"))
	dieIfError(err)
	// populate our list of barclamps
	for _, bc := range dirs {
		if !bc.IsDir() {
			continue
		}
		stat, err = os.Lstat(filepath.Join(path, "barclamps", bc.Name(), ".git"))
		if err != nil {
			log.Println(err)
			continue
		}
		mode := stat.Mode()
		if (mode & (os.ModeDir | os.ModeSymlink)) == 0 {
			continue
		}
		repo, err = git.Open(filepath.Join(path, "barclamps", bc.Name()))
		if err != nil {
			log.Println(err)
			continue
		}
		Barclamps[bc.Name()] = repo
	}
	// populate remotes next

	remotes := Repo.Find("crowbar.remote.")
	var rem *Remote
	for k, v := range remotes {
		parts := strings.Split(k, ".")
		if Remotes[parts[2]] == nil {
			rem = new(Remote)
			rem.Name = parts[2]
			rem.Priority = 50 // default.
			Remotes[parts[2]] = rem
		} else {
			rem = Remotes[parts[2]]
		}
		switch parts[3] {
		case "priority":
			p, e := strconv.Atoi(v)
			if e == nil {
				rem.Priority = p
			}
		case "urlbase":
			rem.Urlbase = v
		}
	}
	meta := new(FlatMetadata)
	err = meta.Probe()
	if err != nil {
		return err
	}
	Meta = meta
	return nil
}

// This is the same as findCrowbar, except we die if we cannot find Crowbar.
func MustFindCrowbar() {
	if Meta == nil {
		dieIfError(findCrowbar(""))
	}
}

// Given a path, chop off the prefix if it matches the path to our working dir.
func RelPath(path string) string {
	return strings.TrimPrefix(filepath.Clean(path),
		filepath.Clean(Repo.WorkDir)+"/")
}

// Get all of the builds we know how to build.
func Builds() BuildMap {
	res := make(BuildMap)
	for _, rel := range Releases() {
		for _, bld := range rel.Builds() {
			res[bld.FullName()] = bld
		}
	}
	return res
}

// Get all the release branches we care about, sorted by barclamp.
func AllBarclampBranches() (res map[string][]string) {
	res = make(map[string][]string)
	for _, build := range Builds() {
		for _, bc := range build.Barclamps() {
			if res[bc.Name] == nil {
				res[bc.Name] = make([]string, 0, 4)
			}
			res[bc.Name] = append(res[bc.Name], bc.Branch)
		}
	}
	return
}

// Get all the barclamp repos, return them in a map whose keys are in the
// of "barclamp-" + the barclamp name.
func AllBarclampRepos() (res RepoMap) {
	res = make(RepoMap)
	for name, bc := range Barclamps {
		res["barclamp-"+name] = bc
	}
	return res
}

func AllOtherRepos() (res RepoMap) {
	res = make(RepoMap)
	res["crowbar"] = Repo
	return res
}

// Get all of the repositories that make up Crowbar.
func AllRepos() (res RepoMap) {
	res = AllBarclampRepos()
	for k, v := range AllOtherRepos() {
		res[k] = v
	}
	return res
}

// Perform a git fetch across all the repositories.
func Fetch(remotes []string) (ok bool, results ResultTokens) {
	repos := AllRepos()
	// mapper and reducer are the functions we will
	// hand over to repoMapReduce.
	// mapper is pretty simple, and doesn't really demonstrate
	// anything useful.
	mapper := func(name string, repo *git.Repo, res resultChan) {
		tok := makeResultToken()
		ok, items := repo.Fetch(remotes)
		// Since you cannot unwind a fetch, use the default commit/rollback functions.
		tok.Name, tok.OK, tok.Results = name, ok, items
		res <- tok
	}
	// reducer iterates over all the results as they arrive,
	// printing status messages along the way and keeping
	// a running idea about which fetches worked.
	// It also serves to show off variable capture.
	reducer := func(vals resultChan) (bool, ResultTokens) {
		ok := true
		res := make(ResultTokens, len(repos), len(repos))
		for i := range res {
			item := <-vals
			res[i] = item
			if item.OK {
				log.Printf("Fetched all updates for %s\n", item.Name)
			} else {
				log.Printf("Failed to fetch all changes for %s:\n", item.Name)
				fetchResults, castOK := item.Results.(git.FetchMap)
				if !castOK {
					log.Panicf("Could not cast fetch results for %s into git.FetchMap\n", item.Name)
				}
				for k, v := range fetchResults {
					if !v {
						log.Printf("\tRemote %s failed\n", k)
					}
				}
			}
			ok = ok && res[i].OK
		}
		return ok, res
	}
	// Now that all the setup is done, do it!
	ok, results = repoMapReduce(repos, mapper, reducer)
	// We do not care about the results of updating tracking branches here.
	UpdateTrackingBranches()
	return
}

// See of all our git repositories are clean.
// Clean means there are no uncommitted changes and no untracked files.
func IsClean() (ok bool, results ResultTokens) {
	repos := AllRepos()
	mapper := func(name string, repo *git.Repo, res resultChan) {
		ok, items := repo.IsClean()
		tok := makeResultToken()
		// There is nothing to unwind or rollback when testing to see
		// if things are clean.
		tok.Name, tok.OK, tok.Results = name, ok, items
		res <- tok
	}
	ok, results = repoMapReduce(repos, mapper, makeBasicReducer(len(repos)))
	return
}

// Get the current build that the repo set is working on.
func CurrentBuild() Build {
	res, found := Repo.Get("crowbar.build")
	if !found {
		return nil
	}
	builds := Builds()
	build, found := builds[res]
	if !found {
		log.Fatalf("Current build %s does not exist!", res)
	}
	return build
}

func setBuild(build Build) {
	Repo.Set("crowbar.build", build.FullName())
	Repo.Set("crowbar.release", build.Release().Name())
}

// Rebase local changes on top of changes from upstream fetched by a Fetch.
func Rebase() (ok bool, res ResultTokens) {
	repos := AllRepos()
	log.Println("Rebasing local branches on remote tracking branches")
	mapper := func(name string, repo *git.Repo, res resultChan) {
		tok := makeResultToken()
		tok.commit, tok.rollback = branchCheckpointer(repo)
		tok.Name, tok.OK, tok.Results = name, true, nil
		for _, branch := range repo.Branches() {
			upstream, err := branch.TrackedRef()
			if err != nil {
				// We don't track anything, don't bother rebasing.
				continue
			}
			if err = branch.RebaseOnto(upstream); err != nil {
				tok.OK = false
				log.Print(err)
				tok.Results = err
				break
			}
		}
		res <- tok
	}
	ok, res = repoMapReduce(repos, mapper, makeBasicReducer(len(repos)))
	return
}

// Get a list of barclamps in a specific Build.
func BarclampsInBuild(build Build) BarclampMap {
	if build == nil {
		log.Panicf("Cannot get barclamps of a nil Build!")
	}
	var res BarclampMap
	if build.Parent() != nil {
		res = BarclampsInBuild(build.Parent())
	} else {
		res = make(BarclampMap)
	}
	for k, v := range build.Barclamps() {
		res[k] = v
	}
	return res
}

func VerifyBarclamps(barclamps BarclampMap) error {
	res := ""
	for _, bc := range barclamps {
		if bc.Repo == nil {
			res += fmt.Sprintf("Missing barclamp %s\n", bc.Name)
			continue
		}
		if _, err := bc.Repo.Ref(bc.Branch); err != nil {
			res += fmt.Sprintf("Barclamp %s does not have branch %s", bc.Name, bc.Branch)
		}
	}
	if res == "" {
		return nil
	}
	return fmt.Errorf(res)
}

// Switch a repository to the empty branch, which will be created
// if it does not exist.
func switchToEmptyBranch(r *git.Repo) error {
	contents := bytes.NewBufferString("This branch intentionally left blank\n")
	readme := filepath.Join(r.WorkDir, "README.empty-branch")
	if ref, err := r.Ref("empty-branch"); err == nil {
		return ref.Checkout()
	}
	cmd, _, _ := r.Git("checkout", "--orphan", "empty-branch")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not create empty-branch")
	}
	cmd, _, _ = r.Git("rm", "-r", "--cached", ".")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not remove index from empty-branch")
	}
	cmd, _, _ = r.Git("clean", "-f", "-x", "-d")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not clean working tree for empty-branch")
	}
	if ioutil.WriteFile(readme, contents.Bytes(), os.FileMode(0644)) != nil {
		return fmt.Errorf("Could not create README.empty-branch")
	}
	cmd, _, _ = r.Git("add", "README.empty-branch")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not add README.empty-branch to empty-branch")
	}
	cmd, _, _ = r.Git("commit", "-m", "Created empty branch.")
	if cmd.Run() != nil {
		return fmt.Errorf("Could not create initial commit to empty-branch")
	}
	return nil
}

// Switch the barclamps to the proper branches for a specific build.
// Any barclamps not involved in the build will be set to the empty branch.
func Switch(build Build) (ok bool, res ResultTokens) {
	newBarclamps := BarclampsInBuild(build)
	if err := VerifyBarclamps(newBarclamps); err != nil {
		log.Print(err)
		log.Fatalln("Please try running dev clone-barclamps to resolve this error.")
	}
	barclampTargets := make(map[string]string)
	for name := range Barclamps {
		if _, found := newBarclamps[name]; found {
			barclampTargets[name] = newBarclamps[name].Branch
		} else {
			barclampTargets[name] = "empty-branch"
		}
	}
	mapper := func(name string, repo *git.Repo, res resultChan) {
		targetBranch := barclampTargets[name]
		tok := makeResultToken()
		tok.Name, tok.OK, tok.Results = name, true, nil
		current, err := repo.CurrentRef()
		if err != nil {
			tok.OK = false
			tok.Results = err
		} else if current.Name() != targetBranch {
			tok.Results = fmt.Errorf("Switched %s to %s", current.Name(), targetBranch)
			if targetBranch == "empty-branch" {
				if err = switchToEmptyBranch(repo); err != nil {
					tok.OK = false
					tok.Results = err
				}
			} else if err = repo.Checkout(targetBranch); err != nil {
				tok.OK = false
				tok.Results = err
			}
		}
		res <- tok
	}
	ok, res = repoMapReduce(Barclamps, mapper, makeBasicReducer(len(barclampTargets)))
	if ok {
		setBuild(build)
		build.FinalizeSwitch()
	}
	return
}
