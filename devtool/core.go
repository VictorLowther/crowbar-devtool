package devtool

import (
	"errors"
	"fmt"
	"github.com/VictorLowther/crowbar-devtool/commands"
	"github.com/VictorLowther/go-git/git"
	"github.com/gonuts/commander"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

// Placeholder for a barclamp.
// Barclamps are leaf nodes from the point of view of the
// release branching stricture.
type Barclamp struct {
	// All barclamps have to have a name.
	Name string
	// This is the branch in git that the barclamp should
	// be checked out to for a build.
	Branch string
	// The git repo that holds the actual code for the barclamp.
	Repo *git.Repo
}

type BarclampMap map[string]*Barclamp

type RepoMap map[string]*git.Repo

// A Build is a bundle of barclamps in a release that
// constitute an installable version of Crowbar
// with an addtional deliverable.
type Build interface {
	// The simple name of the build.  This will be something
	// like "master" or "openstack-os-build"
	Name() string
	// The full name of this build.  It is programatically
	// generated by combining the name of the release with the
	// name of the build.
	FullName() string
	// The Release this build is a member of.
	Release() Release
	// A map of the barclamps that are required for this build.
	// This does not include barclamps from this build's parent!
	Barclamps() BarclampMap
	// The parent of this build.  Every release must contain a master
	// build (which holds the core Crowbar barclamps, and has no parent),
	// and all other builds in a release are children of another build.
	Parent() Build
}

type BuildMap map[string]Build

// A Release is a stream of development for Crowbar.
// At any given time we may have multiple Releases.
// A Release consists of a collection of related builds.
type Release interface {
	// Each release must have a name.
	Name() string
	// The builds that are members of this release.
	Builds() BuildMap
	// The parent of this release.
	// We may return nil if there is no parent.
	Parent() Release
}

type ReleaseMap map[string]Release

// A Metadata allows the rest of Crowbar to know what releases and builds
// are available, and (a little later) modify it.  The reason this
// and the above are interfaces is to allow for having multiple ways to
// store the release metadata.
type Metadata interface {
	// All the releases that this metadata source knows about.
	Releases() ReleaseMap
	// All the builds that this metadata source knows about.
	AllBuilds() BuildMap
	// Test to see if Crowbar is using this metadata.
	Probe(*Crowbar) error
}

type Remote struct {
	Priority int
	Urlbase  string
}

type Crowbar struct {
	Repo      *git.Repo
	Barclamps map[string]*git.Repo
	Remotes   map[string]*Remote
	Meta      Metadata
}

var MemoCrowbar *Crowbar

func dieIfError(e error) {
	if e != nil {
		log.Panic(e)
	}
}

func findCrowbar(path string) (res *Crowbar, err error) {
	if MemoCrowbar != nil {
		return MemoCrowbar, nil
	}
	if path == "" {
		path, err = os.Getwd()
		dieIfError(err)
	}
	path, err = filepath.Abs(path)
	dieIfError(err)
	repo, err := git.Open(path)
	if err != nil {
		return nil, errors.New("Cannot find Crowbar")
	}
	path = repo.Path()
	parent := filepath.Dir(path)
	// If this is a raw repo, recurse and keep looking.
	if repo.IsRaw() {
		res, err = findCrowbar(parent)
		return
	}
	// See if we have something that looks like a crowbar repo here.
	stat, err := os.Stat(filepath.Join(path, "barclamps"))
	if err != nil || !stat.IsDir() {
		res, err = findCrowbar(parent)
		return
	}
	// We do.  Populate the crowbar struct.
	res = &Crowbar{
		Repo:      repo,
		Barclamps: make(map[string]*git.Repo),
		Remotes:   make(map[string]*Remote),
	}
	dirs, err := ioutil.ReadDir(filepath.Join(path, "barclamps"))
	dieIfError(err)
	// populate our list of barclamps
	for _, bc := range dirs {
		if !bc.IsDir() {
			continue
		}
		stat, err = os.Lstat(filepath.Join(path, "barclamps", bc.Name(), ".git"))
		if err != nil {
			log.Println(err)
			continue
		}
		mode := stat.Mode()
		if (mode & (os.ModeDir | os.ModeSymlink)) == 0 {
			continue
		}
		repo, err = git.Open(filepath.Join(path, "barclamps", bc.Name()))
		if err != nil {
			log.Println(err)
			continue
		}
		res.Barclamps[bc.Name()] = repo
	}
	// populate remotes next
	cfg, err := res.Repo.Config()
	dieIfError(err)
	remotes := cfg.Find("crowbar.remote.")
	var rem *Remote
	for k, v := range remotes {
		parts := strings.Split(k, ".")
		if res.Remotes[parts[2]] == nil {
			rem = new(Remote)
			res.Remotes[parts[2]] = rem
		} else {
			rem = res.Remotes[parts[2]]
		}
		switch parts[3] {
		case "priority":
			rem.Priority, _ = strconv.Atoi(v)
		case "urlbase":
			rem.Urlbase = v
		}
	}
	res.Meta = new(FlatMetadata)
	err = res.Meta.Probe(res)
	if err != nil {
		return nil, err
	}
	MemoCrowbar = res
	return res, nil
}

func mustFindCrowbar(path string) *Crowbar {
	res, err := findCrowbar(path)
	dieIfError(err)
	return res
}

func (c *Crowbar) Releases() ReleaseMap {
	return c.Meta.Releases()
}

func (c *Crowbar) Builds() BuildMap {
	return c.Meta.AllBuilds()
}

func (c *Crowbar) Release(release string) Release {
	rels := c.Releases()
	res, ok := rels[release]
	if !ok {
		log.Fatalf("%s is not a release!\n", release)
	}
	return res
}

func ShowCrowbar(cmd *commander.Command, args []string) {
	r := mustFindCrowbar("")
	log.Printf("Crowbar is located at: %s\n", r.Repo.Path())
}

func (c *Crowbar) AllBarclampRepos() (res RepoMap) {
	res = make(RepoMap)
	for name,bc := range c.Barclamps {
		res["barclamp-"+name]=bc
	}
	return res
}

func (c *Crowbar) AllRepos() (res RepoMap) {
	res = c.AllBarclampRepos()
	res["Crowbar"] = c.Repo
	return res
}

type resultToken struct {
	name string
	ok bool
	results interface{}
}

type resultTokens []*resultToken

type resultChan chan *resultToken

type repoMapper func (string, *git.Repo, resultChan)

type repoReducer func (resultChan) (bool, resultTokens)

func repoMapReduce(repos RepoMap, mapper repoMapper, reducer repoReducer) (ok bool, res resultTokens) {
	results := make(resultChan)
	defer close(results)
	for name,repo := range repos {
		go mapper(name,repo,results)
	}
	ok,res = reducer(results)
	return ok, res
}

func (c *Crowbar) fetch(remotes []string) (ok bool, results resultTokens) {
	repos := c.AllRepos()
	mapper := func (name string, repo *git.Repo, res resultChan) {
		ok,items := repo.Fetch(remotes)
		res <- &resultToken{
			name: name,
			ok: ok,
			results: items,
		}
	}
	reducer := func (vals resultChan) (bool, resultTokens) {
		ok := true
		res := make(resultTokens,len(repos),len(repos))
		for i,_ := range res {
			item := <- vals
			res[i] = item
			if item.ok {
				log.Printf("Fetched all updates for %s\n",item.name)
			} else {
				log.Printf("Failed to fetch all changes for %s:\n", item.name)
				fetch_results,cast_ok := item.results.(git.FetchMap)
				if ! cast_ok {
					log.Panicf("Could not cast fetch results for %s into git.FetchMap\n",item.name)
				} 
				for k, v := range fetch_results {
					if !v {
						log.Printf("\tRemote %s failed\n", k)
					}
				}
			}
			ok = ok && res[i].ok
		}
		return ok, res
	}
	ok, results = repoMapReduce(repos,mapper,reducer)
	return
}

func (c *Crowbar) currentRelease() Release {
	cfg, err := c.Repo.Config()
	dieIfError(err)
	res, found := cfg.Get("crowbar.release")
	if found {
		return c.Release(res)
	}
	return nil
}

func (c *Crowbar) currentBuild() Build {
	cfg, err := c.Repo.Config()
	dieIfError(err)
	res, found := cfg.Get("crowbar.build")
	if !found {
		return nil
	}
	builds := c.Builds()
	build, found := builds[res]
	if !found {
		log.Fatalf("Current build %s does not exist!", res)
	}
	return build
}

func (c *Crowbar) barclampsInBuild(build Build) BarclampMap {
	if build == nil {
		log.Panicf("Cannot get barclamps of a nil Build!")
	}
	var res BarclampMap
	if build.Parent() != nil {
		res = c.barclampsInBuild(build.Parent())
	} else {
		res = make(BarclampMap)
	}
	for k, v := range build.Barclamps() {
		res[k] = v
	}
	return res
}

func Fetch(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	ok, _ := c.fetch(nil)
	if ok {
		log.Printf("All updates fetched.\n")
		os.Exit(0)
	}
	os.Exit(1)
}

func ShowRelease(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	fmt.Println(c.currentRelease().Name())
}

func ShowBuild(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	fmt.Println(c.currentBuild().FullName())
}

func Releases(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	for release, _ := range c.Releases() {
		res = append(res, release)
	}
	sort.Strings(res)
	for _, release := range res {
		fmt.Println(release)
	}
}

func Builds(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	if len(args) == 0 {
		for build, _ := range c.currentRelease().Builds() {
			res = append(res, c.currentRelease().Name()+"/"+build)
		}
	} else {
		for _, release := range args {
			for build, _ := range c.Release(release).Builds() {
				res = append(res, release+"/"+build)
			}
		}
	}
	sort.Strings(res)
	for _, build := range res {
		fmt.Println(build)
	}
}

func BarclampsInBuild(cmd *commander.Command, args []string) {
	c := mustFindCrowbar("")
	res := make([]string, 0, 20)
	var build Build
	var found bool
	if len(args) == 0 {
		build = c.currentBuild()
	} else if len(args) == 1 {
		builds := c.Builds()
		build, found = builds[args[0]]
		if !found {
			log.Fatalln("No such build %s", args[0])
		}
	}
	for name, _ := range c.barclampsInBuild(build) {
		res = append(res, name)
	}
	sort.Strings(res)
	for _, name := range res {
		fmt.Println(name)
	}
}

func init() {
	commands.AddCommand(
		&commander.Command{
			Run:       Releases,
			UsageLine: "releases",
			Short:     "Shows the releases available to work on.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       BarclampsInBuild,
			UsageLine: "barclamps-in-build [build]",
			Short:     "Shows the releases available to work on.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       Builds,
			UsageLine: "builds",
			Short:     "Shows the builds in a release or releases.",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowRelease,
			UsageLine: "release",
			Short:     "Shows the current release",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowBuild,
			UsageLine: "branch",
			Short:     "Shows the current branch",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       ShowCrowbar,
			UsageLine: "show",
			Short:     "Shows the location of the top level Crowbar repo",
		})
	commands.AddCommand(
		&commander.Command{
			Run:       Fetch,
			UsageLine: "fetch",
			Short:     "Fetches updates from all remotes",
		})
	return
}

func Run() {
	commands.Run()
	return
}
